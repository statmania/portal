<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Drawing Board ‚Äì Pen Fixed</title>
<style>
  :root {
    --panel-width: 7vw; /* ~5‚Äì8% */
    --panel-bg: #1f2937;
    --panel-fg: #e5e7eb;
    --accent: #3b82f6;
    --gap: 0.5rem;
    --btn-size: 40px;
  }
  html, body {
    margin: 0; padding: 0; background: #111827; height: 100%; overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #board, #overlay {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; touch-action: none;
  }
  #overlay { pointer-events: none; }

  /* Top-right toggle button (always visible) */
  #toggleControls {
    position: fixed; top: 0.5rem; right: 0.5rem;
    width: var(--btn-size); height: var(--btn-size);
    border: none; border-radius: 0.35rem; cursor: pointer;
    background: var(--panel-bg); color: var(--panel-fg);
    font-size: 20px; z-index: 10; display: grid; place-items: center;
    box-shadow: 0 2px 8px rgba(0,0,0,.4);
  }

  /* Controls panel (hidden by default) */
  #controls {
    position: fixed; top: calc(var(--btn-size) + 1rem); right: 0.5rem;
    width: var(--panel-width);
    background: var(--panel-bg); color: var(--panel-fg);
    box-sizing: border-box; padding: 0.75rem;
    display: none; flex-direction: column; gap: var(--gap);
    border-radius: 0.4rem;
    box-shadow: 0 4px 16px rgba(0,0,0,.35);
    max-height: calc(100vh - var(--btn-size) - 2rem);
    overflow-y: auto;
  }

  .section { display: flex; flex-direction: column; gap: 0.35rem; }
  .icon-btns { display: flex; flex-direction: column; gap: 0.35rem; }

  button.tool, button.action {
    background: rgba(255,255,255,0.06); border: 1px solid transparent;
    border-radius: 0.35rem; padding: 0.35rem; cursor: pointer; color: inherit;
    display: flex; align-items: center; justify-content: center; height: 36px; font-size: 20px;
  }
  button.tool.active { border-color: var(--accent); background: rgba(59,130,246,0.15); }

  input[type="color"], input[type="range"] { width: 100%; }
  select {
    width: 100%; background: rgba(255,255,255,0.06); border: none; color: inherit;
    padding: 0.25rem; border-radius: 0.35rem;
  }
</style>
</head>
<body>
<canvas id="board"></canvas>
<canvas id="overlay"></canvas>

<button id="toggleControls" aria-label="Toggle controls">‚ò∞</button>

<aside id="controls" aria-label="Drawing controls">
  <div class="section icon-btns">
    <button style="color:yellow;" class="tool active" data-tool="pen" title="Pen">üñâ</button>
    <select id="shapeSelect" title="Shape">
      <option value="freehand" selected>Freehand</option>
      <option value="line">Line</option>
      <option value="rect">Rectangle</option>
      <option value="circle">Circle</option>
    </select>
    <button  class="tool" data-tool="eraser" title="Eraser">ü©π</button>
  </div>

  <div class="section">
    <input id="penColor" type="color" value="#ffffff" title="Pen color" />
    <input id="penSize" type="range" min="1" max="100" value="4" title="Pen size" />
    <input id="eraserSize" type="range" min="5" max="200" value="20" title="Eraser size" />
    <input id="bgColorPicker" type="color" value="#111827" title="Background color" />
  </div>

  <div class="section icon-btns">
    <button class="action" id="undoBtn" title="Undo">‚Ü∂</button>
    <button class="action" id="clearBtn" title="Delete All">üóëÔ∏è</button>
  </div>
</aside>

<script>
(() => {
  const board = document.getElementById('board');
  const overlay = document.getElementById('overlay');
  const ctx = board.getContext('2d');
  const octx = overlay.getContext('2d');

  const controls = document.getElementById('controls');
  const toggleBtn = document.getElementById('toggleControls');

  const toolBtns = Array.from(document.querySelectorAll('button.tool'));
  const penColorEl = document.getElementById('penColor');
  const penSizeEl = document.getElementById('penSize');
  const eraserSizeEl = document.getElementById('eraserSize');
  const shapeSelect = document.getElementById('shapeSelect');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const bgColorPicker = document.getElementById('bgColorPicker');

  let currentTool = 'pen';
  let currentShape = 'freehand';
  let drawing = false;
  let startX = 0, startY = 0, lastX = 0, lastY = 0;
  let undoStack = []; const MAX_UNDO = 50;

  const state = {
    penColor: penColorEl.value,
    penSize: +penSizeEl.value,
    eraserSize: +eraserSizeEl.value
  };

  // Toggle controls visibility
  controls.style.display = 'none';
  toggleBtn.addEventListener('click', () => {
    const show = controls.style.display === 'none';
    controls.style.display = show ? 'flex' : 'none';
  });

  function resizeCanvas() {
    const w = window.innerWidth, h = window.innerHeight;
    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    temp.getContext('2d').drawImage(board, 0, 0);
    board.width = w; board.height = h;
    overlay.width = w; overlay.height = h;
    ctx.drawImage(temp, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function pushUndo() {
    try {
      if (undoStack.length >= MAX_UNDO) undoStack.shift();
      undoStack.push(ctx.getImageData(0, 0, board.width, board.height));
    } catch (_) {}
  }
  function restore(img){ ctx.putImageData(img, 0, 0); }
  function clearOverlay(){ octx.clearRect(0, 0, overlay.width, overlay.height); }

  function drawFreehand(fromX, fromY, toX, toY) {
    if (currentTool === 'eraser') {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = state.eraserSize;
      ctx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.lineWidth = state.penSize;
      ctx.strokeStyle = state.penColor;
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    ctx.closePath();
  }

  function previewShape(x1,y1,x2,y2){
    clearOverlay();
    octx.globalCompositeOperation = 'source-over';
    octx.lineWidth = (currentTool === 'eraser') ? state.eraserSize : state.penSize;
    octx.strokeStyle = (currentTool === 'eraser') ? '#ff4d4d' : state.penColor;
    octx.setLineDash([4,3]);
    if (currentShape === 'line') {
      octx.beginPath(); octx.moveTo(x1,y1); octx.lineTo(x2,y2); octx.stroke();
    } else if (currentShape === 'rect') {
      octx.strokeRect(x1, y1, x2-x1, y2-y1);
    } else if (currentShape === 'circle') {
      const r = Math.hypot(x2-x1, y2-y1);
      octx.beginPath(); octx.arc(x1, y1, r, 0, Math.PI * 2); octx.stroke();
    }
    octx.setLineDash([]);
  }

  function commitShape(x1,y1,x2,y2){
    ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
    ctx.lineWidth = (currentTool === 'eraser') ? state.eraserSize : state.penSize;
    ctx.strokeStyle = (currentTool === 'eraser') ? 'rgba(0,0,0,1)' : state.penColor;
    if (currentShape === 'line') {
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    } else if (currentShape === 'rect') {
      ctx.strokeRect(x1, y1, x2-x1, y2-y1);
    } else if (currentShape === 'circle') {
      const r = Math.hypot(x2-x1, y2-y1);
      ctx.beginPath(); ctx.arc(x1, y1, r, 0, Math.PI * 2); ctx.stroke();
    }
  }

  function getPos(e){
    const rect = board.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function startDraw(e){
    drawing = true;
    const {x,y} = getPos(e);
    startX = lastX = x; startY = lastY = y;
    pushUndo();
    if (currentShape === 'freehand') {
      drawFreehand(x,y,x,y); // click-dot
    } else {
      previewShape(startX,startY,x,y);
    }
  }

  function moveDraw(e){
    if (!drawing) return;
    const {x,y} = getPos(e);
    if (currentShape === 'freehand') {
      drawFreehand(lastX,lastY,x,y);
      lastX = x; lastY = y;
    } else {
      previewShape(startX,startY,x,y);
    }
  }

  function endDraw(e){
    if (!drawing) return;
    drawing = false;
    const {x,y} = getPos(e);
    if (currentShape !== 'freehand') {
      clearOverlay();
      commitShape(startX,startY,x,y);
    }
    ctx.globalCompositeOperation = 'source-over';
  }

  // Attach draw events
  board.addEventListener('mousedown', startDraw);
  board.addEventListener('mousemove', moveDraw);
  window.addEventListener('mouseup', endDraw);

  board.addEventListener('touchstart', e => { e.preventDefault(); startDraw(e); }, { passive: false });
  board.addEventListener('touchmove',  e => { e.preventDefault(); moveDraw(e);  }, { passive: false });
  board.addEventListener('touchend',   e => { e.preventDefault(); endDraw(e);   }, { passive: false });

  // Tool switching
  toolBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      toolBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTool = btn.dataset.tool;
    });
  });

  // Inputs
  penColorEl.addEventListener('input', e => state.penColor = e.target.value);
  penSizeEl.addEventListener('input', e => state.penSize = +e.target.value);
  eraserSizeEl.addEventListener('input', e => state.eraserSize = +e.target.value);
  shapeSelect.addEventListener('change', e => currentShape = e.target.value);
  bgColorPicker.addEventListener('input', e => document.body.style.background = e.target.value);

  // History
  undoBtn.addEventListener('click', () => { if (undoStack.length) restore(undoStack.pop()); });
  clearBtn.addEventListener('click', () => { pushUndo(); ctx.clearRect(0,0,board.width,board.height); });
})();
</script>
</body>
</html>
