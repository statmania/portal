<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Drawing Board ‚Äì Full</title>
<style>
  :root {
    --panel-width: 10vw;
    --panel-width-mobile: 15vw;
    --panel-bg: #1f2937;
    --panel-fg: #e5e7eb;
    --accent: #3b82f6;
    --gap: 0.75rem;
    --btn-size: 48px;
    --font-size: 28px;
  }
  html, body {
    margin: 0; padding: 0; background: #ccc; height: 100%; overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #board, #overlay {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; touch-action: none;
  }
  #overlay { pointer-events: none; }

  #penCursor {
    position: absolute; width: 40px; height: 40px; pointer-events: none; transform: rotate(135deg); display: none;
  }
  #eraserCursor {
    position: absolute; border: 2px solid #ff4d4d; border-radius: 50%; pointer-events: none; display: none; box-sizing: border-box; background: transparent;
  }

  #toggleControls {
    position: fixed; top: 0.5rem; right: 0.5rem;
    width: var(--btn-size); height: var(--btn-size);
    border: none; border-radius: 0.35rem; cursor: pointer;
    background: var(--panel-bg); color: var(--panel-fg);
    font-size: 24px; z-index: 10; display: grid; place-items: center;
    box-shadow: 0 2px 8px rgba(0,0,0,.4);
  }

  #controls {
    position: fixed; top: calc(var(--btn-size) + 1rem); right: 0.5rem;
    width: var(--panel-width);
    background: var(--panel-bg); color: var(--panel-fg);
    box-sizing: border-box; padding: 1rem;
    display: none; flex-direction: column; gap: var(--gap);
    border-radius: 0.4rem; box-shadow: 0 4px 16px rgba(0,0,0,.35);
    max-height: calc(100vh - var(--btn-size) - 2rem);
    overflow-y: auto;
  }
  .section { display: flex; flex-direction: column; gap: 0.5rem; }
  button.tool, button.action {
    background: rgba(255,255,255,0.06); border: 1px solid transparent;
    border-radius: 0.5rem; padding: 0.5rem; cursor: pointer; color: inherit;
    display: flex; align-items: center; justify-content: center;
    height: var(--btn-size); font-size: var(--font-size);
    user-select: none; transition: background-color 0.2s, border-color 0.2s;
  }
  button.tool.active { border-color: var(--accent); background: rgba(59,130,246,0.15); }
  .pen-icon { filter: drop-shadow(0 0 2px yellow) drop-shadow(0 0 5px yellow); }
  input[type="color"], input[type="range"], select {
    height: 36px; border-radius: 0.35rem; background: rgba(255,255,255,0.06);
    border: none; color: inherit; padding: 0 0.5rem; margin-top: 0.25rem;
  }
  @media (max-width: 768px) {
    :root { --panel-width: var(--panel-width-mobile); --btn-size: 56px; --font-size: 32px; --gap: 1rem; }
    input[type="color"], input[type="range"], select { height: 44px; }
    #controls { right: 0.25rem; padding: 0.75rem; }
  }
</style>
</head>
<body>
<canvas id="board"></canvas>
<canvas id="overlay"></canvas>
<img id="penCursor" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFD60A'><path d='M2 21l1-4 12-12 4 4-12 12-4 1z'/></svg>" alt="Pen cursor" />
<div id="eraserCursor"></div>

<button id="toggleControls" aria-label="Toggle controls">‚ò∞</button>

<aside id="controls" aria-label="Drawing controls">
  <div class="section">
    <button class="tool active" data-tool="pen" title="Pen"><img class="pen-icon" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFD60A'><path d='M2 21l1-4 12-12 4 4-12 12-4 1z'/></svg>" width="24" height="24" /></button>
    <select id="shapeSelect" title="Shape">
      <option value="freehand" selected>Freehand</option>
      <option value="line">Line</option>
      <option value="rect">Rectangle</option>
      <option value="circle">Circle</option>
      <option value="pentagon">Pentagon</option>
    </select>
    <input id="sizeSlider" type="range" min="1" max="200" value="4" title="Size" />
    <button class="tool" data-tool="eraser" title="Eraser">ü©π</button>
  </div>
  <div class="section">
    <input id="penColor" type="color" value="#000000" title="Pen color" />
    <input id="bgColorPicker" type="color" value="#cccccc" title="Background color" />
  </div>
  <div class="section">
    <button class="action" id="undoBtn" title="Undo">‚Ü∂</button>
    <button class="action" id="clearBtn" title="Delete All">üóëÔ∏è</button>
  </div>
</aside>

<script>
(() => {
  const board = document.getElementById('board');
  const overlay = document.getElementById('overlay');
  const ctx = board.getContext('2d');
  const octx = overlay.getContext('2d');
  const penCursor = document.getElementById('penCursor');
  const eraserCursor = document.getElementById('eraserCursor');
  const controls = document.getElementById('controls');
  const toggleBtn = document.getElementById('toggleControls');
  const toolBtns = Array.from(document.querySelectorAll('button.tool'));
  const shapeSelect = document.getElementById('shapeSelect');
  const sizeSlider = document.getElementById('sizeSlider');
  const penColorEl = document.getElementById('penColor');
  const bgColorPicker = document.getElementById('bgColorPicker');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');

  let currentTool = 'pen';
  let currentShape = 'freehand';
  let drawing = false;
  let startX = 0, startY = 0, lastX = 0, lastY = 0;
  let undoStack = [];
  const MAX_UNDO = 50;
  let penSize = 4;
  let eraserSize = 20;
  const state = { penColor: penColorEl.value };

  controls.style.display = 'none';
  toggleBtn.addEventListener('click', () => {
    controls.style.display = (controls.style.display === 'none') ? 'flex' : 'none';
  });

  function resizeCanvas() {
    const w = window.innerWidth, h = window.innerHeight;
    const temp = document.createElement('canvas');
    temp.width = board.width; temp.height = board.height;
    temp.getContext('2d').drawImage(board, 0, 0);
    board.width = w; board.height = h;
    overlay.width = w; overlay.height = h;
    ctx.drawImage(temp, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function pushUndo() {
    if (undoStack.length >= MAX_UNDO) undoStack.shift();
    undoStack.push(ctx.getImageData(0, 0, board.width, board.height));
  }
  function restore(img) { ctx.putImageData(img, 0, 0); }
  function clearOverlay() { octx.clearRect(0, 0, overlay.width, overlay.height); }
  function currentSize() { return currentTool === 'eraser' ? eraserSize : penSize; }
  function applySliderToTool() { if (currentTool === 'eraser') eraserSize = +sizeSlider.value; else penSize = +sizeSlider.value; updateEraserCursorSize(); }
  function syncSliderToTool() { sizeSlider.value = currentTool === 'eraser' ? eraserSize : penSize; updateEraserCursorSize(); }
  function updateEraserCursorSize() { eraserCursor.style.width = eraserSize + 'px'; eraserCursor.style.height = eraserSize + 'px'; }

  function drawFreehand(fromX, fromY, toX, toY) {
    ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
    ctx.lineWidth = currentSize();
    ctx.strokeStyle = currentTool === 'eraser' ? 'rgba(0,0,0,1)' : state.penColor;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke(); ctx.closePath();
  }

  function previewShape(x1, y1, x2, y2) {
    if (currentTool === 'eraser') return;
    clearOverlay();
    octx.globalCompositeOperation = 'source-over';
    octx.lineWidth = currentSize();
    octx.strokeStyle = state.penColor;
    octx.setLineDash([4,3]);
    if (currentShape === 'line') { octx.beginPath(); octx.moveTo(x1, y1); octx.lineTo(x2, y2); octx.stroke(); }
    else if (currentShape === 'rect') { octx.strokeRect(x1, y1, x2 - x1, y2 - y1); }
    else if (currentShape === 'circle') { const r = Math.hypot(x2 - x1, y2 - y1); octx.beginPath(); octx.arc(x1, y1, r, 0, Math.PI * 2); octx.stroke(); }
    else if (currentShape === 'pentagon') { const r = Math.hypot(x2 - x1, y2 - y1); drawPolygon(octx, x1, y1, 5, r); }
    octx.setLineDash([]);
  }
  function commitShape(x1, y1, x2, y2) {
    if (currentTool === 'eraser') return;
    ctx.globalCompositeOperation = 'source-over';
    ctx.lineWidth = currentSize();
    ctx.strokeStyle = state.penColor;
    if (currentShape === 'line') { ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); }
    else if (currentShape === 'rect') { ctx.strokeRect(x1, y1, x2 - x1, y2 - y1); }
    else if (currentShape === 'circle') { const r = Math.hypot(x2 - x1, y2 - y1); ctx.beginPath(); ctx.arc(x1, y1, r, 0, Math.PI * 2); ctx.stroke(); }
    else if (currentShape === 'pentagon') { const r = Math.hypot(x2 - x1, y2 - y1); drawPolygon(ctx, x1, y1, 5, r); }
  }
  function drawPolygon(context, cx, cy, sides, r) {
    context.beginPath();
    for (let i = 0; i < sides; i++) {
      const angle = (-Math.PI / 2) + i * (2 * Math.PI / sides);
      const x = cx + r * Math.cos(angle);
      const y = cy + r * Math.sin(angle);
      if (i === 0) context.moveTo(x, y); else context.lineTo(x, y);
    }
    context.closePath();
    context.stroke();
  }

  function getPos(e) {
    const rect = board.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }
  function startDraw(e) {
    drawing = true;
    updateCursorDisplay(true);
    const { x, y } = getPos(e); startX = lastX = x; startY = lastY = y;
    pushUndo();
    if (currentShape === 'freehand' || currentTool === 'eraser') drawFreehand(x, y, x, y);
    else previewShape(startX, startY, x, y);
    moveCursor(x, y);
  }
  function moveDraw(e) {
    const { x, y } = getPos(e);
    moveCursor(x, y);
    if (!drawing) return;
    if (currentShape === 'freehand' || currentTool === 'eraser') { drawFreehand(lastX, lastY, x, y); lastX = x; lastY = y; }
    else previewShape(startX, startY, x, y);
  }
  function endDraw(e) {
    if (!drawing) return; drawing = false;
    const { x, y } = getPos(e);
    if (currentShape !== 'freehand' && currentTool !== 'eraser') { clearOverlay(); commitShape(startX, startY, x, y); }
    ctx.globalCompositeOperation = 'source-over'; updateCursorDisplay(false);
  }

  function moveCursor(x, y) {
    if (currentTool === 'pen') {
      penCursor.style.left = (x - 5) + 'px'; penCursor.style.top = (y - 35) + 'px';
    } else if (currentTool === 'eraser') {
      eraserCursor.style.left = (x - eraserSize/2) + 'px'; eraserCursor.style.top = (y - eraserSize/2) + 'px';
    }
  }
  function updateCursorDisplay(active) {
    penCursor.style.display = (currentTool === 'pen' && active) ? 'block' : 'none';
    eraserCursor.style.display = (currentTool === 'eraser' && active) ? 'block' : 'none';
  }

  board.addEventListener('mousedown', startDraw);
  board.addEventListener('mousemove', moveDraw);
  window.addEventListener('mouseup', endDraw);
  board.addEventListener('touchstart', e => { e.preventDefault(); startDraw(e); }, { passive: false });
  board.addEventListener('touchmove', e => { e.preventDefault(); moveDraw(e); }, { passive: false });
  board.addEventListener('touchend', e => { e.preventDefault(); endDraw(e); }, { passive: false });

  toolBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      toolBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTool = btn.dataset.tool; syncSliderToTool();
      penCursor.style.display = 'none'; eraserCursor.style.display = 'none';
    });
  });
  sizeSlider.addEventListener('input', applySliderToTool);
  penColorEl.addEventListener('input', e => state.penColor = e.target.value);
  shapeSelect.addEventListener('change', e => currentShape = e.target.value);
  bgColorPicker.addEventListener('input', e => document.body.style.background = e.target.value);
  undoBtn.addEventListener('click', () => { if (undoStack.length) restore(undoStack.pop()); });
  clearBtn.addEventListener('click', () => { pushUndo(); ctx.clearRect(0, 0, board.width, board.height); });
  syncSliderToTool();
})();
</script>
</body>
</html>
