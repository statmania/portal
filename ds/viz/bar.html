<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bar Plot Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner look */
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-gray-50 text-gray-800;
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            /* Height will be set by JavaScript to match width for square aspect ratio */
            /* Adjusted max-width and max-height for a slightly smaller plot */
            max-width: 500px; /* Reduced from 600px */
            max-height: 500px; /* Reduced from 600px */
        }
        input[type="text"], textarea {
            @apply w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500;
        }
        /* Updated button styling for generatePlotBtn */
        #generatePlotBtn {
            @apply bg-gradient-to-r from-indigo-500 to-purple-600 text-white py-2 px-6 rounded-lg shadow-lg hover:from-indigo-600 hover:to-purple-700 transition transform duration-200 ease-in-out hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 border border-indigo-700;
        }
        /* Updated button styling for sortAscendingBtn to be a darker gray */
        #sortAscendingBtn {
            @apply bg-gray-700 text-white py-2 px-6 rounded-lg shadow-md hover:bg-gray-800 transition transform duration-200 ease-in-out hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-opacity-50 border border-gray-600;
        }
        /* Style for the message box */
        #messageBox {
            @apply fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50 hidden;
        }
        #messageBoxContent {
            @apply bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center;
        }
        #messageBoxButton {
            @apply mt-4 bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700;
        }

        /* Table styling for input */
        .input-table {
            @apply w-full border-collapse;
        }
        .input-table th, .input-table td {
            @apply border border-gray-300 p-2 text-sm;
        }
        .input-table th {
            @apply bg-gray-100 font-semibold text-gray-700;
        }
        .input-table input[type="text"] {
            @apply w-full p-1 border border-gray-200 rounded-sm focus:ring-blue-300 focus:border-blue-300;
        }
        .input-table .delete-row-btn {
            @apply bg-red-500 text-white p-1 rounded hover:bg-red-600 transition duration-150 ease-in-out;
            width: 28px; /* Fixed width for consistent button size */
            height: 28px; /* Fixed height for consistent button size */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
        }
        .add-row-btn {
            @apply bg-green-500 text-white py-1 px-3 rounded hover:bg-green-600 transition duration-150 ease-in-out mt-2;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <!-- Main Container -->
    <div class="flex flex-col md:flex-row gap-6 md:gap-8 max-w-7xl mx-auto">

        <!-- Options Panel (Left/Top) -->
        <div class="flex-shrink-0 w-full md:w-1/3 bg-white p-6 rounded-xl shadow-lg border border-gray-100">
            <h1 class="text-3xl font-bold text-center mb-6 md:mb-8 text-indigo-700">Bar Plot Generator</h1>
            <!-- The scrollable content starts below this title -->
            <div class="max-h-[calc(100vh-8rem-6rem)] overflow-y-auto pb-4"> <!-- Added pb-4 for spacing before button -->
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Plot Settings</h2>

                <!-- Input Method Selection -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Input Method:</label>
                    <div class="flex space-x-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="inputMethod" value="commaSeparated" class="form-radio" checked>
                            <span class="ml-2 text-gray-700">Comma Separated</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="inputMethod" value="tableInput" class="form-radio">
                            <span class="ml-2 text-gray-700">Table Input</span>
                        </label>
                    </div>
                </div>

                <!-- Comma Separated Input Fields -->
                <div id="commaSeparatedInput" class="input-section">
                    <div class="mb-4">
                        <label for="valuesInput" class="block text-sm font-medium text-gray-700 mb-1">Values (comma-separated numbers):</label>
                        <div class="flex items-center space-x-2">
                            <input type="text" id="valuesInput" value="50,70,30,90,60" placeholder="e.g., 10,20,30">
                            <span id="valuesCountDisplay" class="text-sm text-gray-600 flex-shrink-0"></span>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Example: 50,70,30,90,60</p>
                    </div>

                    <div class="mb-4">
                        <label for="categoriesInput" class="block text-sm font-medium text-gray-700 mb-1">Categories (comma-separated text):</label>
                        <div class="flex items-center space-x-2">
                            <input type="text" id="categoriesInput" value="A,B,C,D,E" placeholder="e.g., Apples,Oranges,Bananas">
                            <span id="categoriesHintDisplay" class="text-sm text-gray-600 flex-shrink-0"></span>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Example: A,B,C,D,E</p>
                    </div>
                </div>

                <!-- Table Input Fields -->
                <div id="tableInput" class="input-section hidden">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Data Table</h3>
                    <table class="input-table mb-2">
                        <thead>
                            <tr>
                                <th>Value</th>
                                <th>Category</th>
                                <th>Color</th>
                                <th>Width (%)</th>
                                <th></th> <!-- For delete button -->
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                            <!-- Rows will be added here by JavaScript -->
                        </tbody>
                    </table>
                    <button type="button" id="addRowBtn" class="add-row-btn">Add Row</button>
                    <p class="text-xs text-gray-500 mt-2">You can paste data from Excel (Ctrl+V or Cmd+V) into any cell.</p>
                </div>


                <!-- Input fields for Plot Title, X-Axis Label, Y-Axis Label -->
                <div class="mb-4">
                    <label for="plotTitleInput" class="block text-sm font-medium text-gray-700 mb-1">Plot Title:</label>
                    <input type="text" id="plotTitleInput" value="Sample Bar Chart" placeholder="e.g., Sales by Region">
                </div>

                <div class="mb-4">
                    <label for="xAxisLabelInput" class="block text-sm font-medium text-gray-700 mb-1">X-Axis Label:</label>
                    <input type="text" id="xAxisLabelInput" value="Categories" placeholder="e.g., Product Types">
                </div>

                <div class="mb-4">
                    <label for="yAxisLabelInput" class="block text-sm font-medium text-gray-700 mb-1">Y-Axis Label:</label>
                    <input type="text" id="yAxisLabelInput" value="Values" placeholder="e.g., Quantity Sold">
                </div>

                <div class="mb-4">
                    <label for="colorsInput" class="block text-sm font-medium text-gray-700 mb-1">Colors (optional, comma-separated, accepts hex/named colors):</label>
                    <input type="text" id="colorsInput" value="#6366F1,#8B5CF6,#EC4899,#F59E0B,#10B981" placeholder="e.g., red,blue,#FFC0CB">
                    <p class="text-xs text-gray-500 mt-1">Example: #6366F1,#8B5CF6,#EC4899,#F59E0B,#10B981</p>
                </div>

                <div class="mb-6">
                    <label for="widthsInput" class="block text-sm font-medium text-gray-700 mb-1">Bar Widths (optional, comma-separated percentages 0-100):</label>
                    <input type="text" id="widthsInput" value="50" placeholder="e.g., 50,70,90"> <!-- Changed default value to 50 -->
                    <p class="text-xs text-gray-500 mt-1">Example: 50 (for equal width), or 70,80,90 for custom widths</p>
                </div>
                <!-- Removed generatePlotBtn from here -->
            </div>
            <!-- generatePlotBtn moved here, outside the scrollable div -->
            <!-- Remove the generate plot button entirely -->
            <!-- <button id="generatePlotBtn" class="w-full mt-4">Generate Plot</button> -->
        </div>

        <!-- Chart Container (Right/Bottom) -->
        <!-- Added flex-col to stack canvas and button -->
        <div class="flex-grow bg-white p-4 rounded-xl shadow-lg border border-gray-100 flex flex-col items-center justify-center min-h-[300px] md:min-h-[500px]">

            <canvas id="barChartCanvas" class="flex-grow"></canvas>
            <!-- Moved button for sorting below the canvas -->
            <!-- Added w-fit and mx-auto for centering and content-based width -->
            <div class="mt-4 w-full flex justify-center px-4">
                <button id="sortAscendingBtn">Sort Ascending</button>
            </div>
        </div>
    </div>

    <!-- Message Box for alerts -->
    <div id="messageBox">
        <div id="messageBoxContent">
            <p id="messageBoxText" class="text-lg font-medium mb-4"></p>
            <button id="messageBoxButton">OK</button>
        </div>
    </div>

    <script>
        // Get references to DOM elements
        const valuesInput = document.getElementById('valuesInput');
        const categoriesInput = document.getElementById('categoriesInput');
        const plotTitleInput = document.getElementById('plotTitleInput');
        const xAxisLabelInput = document.getElementById('xAxisLabelInput');
        const yAxisLabelInput = document.getElementById('yAxisLabelInput');
        const colorsInput = document.getElementById('colorsInput');
        const widthsInput = document.getElementById('widthsInput');
        // const generatePlotBtn = document.getElementById('generatePlotBtn'); // Removed
        const sortAscendingBtn = document.getElementById('sortAscendingBtn');
        const barChartCanvas = document.getElementById('barChartCanvas');
        const ctx = barChartCanvas.getContext('2d');

        // New display elements
        const valuesCountDisplay = document.getElementById('valuesCountDisplay');
        const categoriesHintDisplay = document.getElementById('categoriesHintDisplay');
        const commaSeparatedInput = document.getElementById('commaSeparatedInput');
        const tableInput = document.getElementById('tableInput');
        const inputMethodRadios = document.querySelectorAll('input[name="inputMethod"]');
        const dataTableBody = document.getElementById('dataTableBody');
        const addRowBtn = document.getElementById('addRowBtn');


        // Message Box elements
        const messageBox = document.getElementById('messageBox');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxButton = document.getElementById('messageBoxButton');

        // Flag to indicate if the currently displayed chart is sorted
        let currentChartIsSorted = false;

        // Function to show custom message box
        function showMessageBox(message) {
            messageBoxText.textContent = message;
            messageBox.classList.remove('hidden');
        }

        // Event listener for message box button
        messageBoxButton.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        // Default colors for the bars
        const defaultColors = [
            '#6366F1', // Indigo
            '#8B5CF6', // Violet
            '#EC4899', // Pink
            '#F59E0B', // Amber
            '#10B981', // Emerald
            '#3B82F6', // Blue
            '#EF4444', // Red
            '#06B6D4', // Cyan
            '#6B7280'  // Gray
        ];

        /**
         * Draws a bar chart on the canvas.
         * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
         * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
         * @param {number[]} values - Array of numerical values for the bars.
         * @param {string[]} categories - Array of category labels for the bars.
         * @param {string} plotTitle - Title of the plot.
         * @param {string} xAxisLabel - Label for the X-axis.
         * @param {string} yAxisLabel - Label for the Y-axis.
         * @param {string[]} colors - Array of colors for each bar.
         * @param {number[]} widths - Array of widths (0-100%) for each bar relative to available space.
         */
        function drawBarChart(canvas, ctx, values, categories, plotTitle, xAxisLabel, yAxisLabel, colors, widths) {
            // Clear the canvas before drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get canvas dimensions
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            // Define padding and margins for the chart
            // Adjusted padding to account for title and axis labels
            const topPadding = 50;
            const bottomPadding = 40; // For X-axis label
            const leftPadding = 60; // For Y-axis label
            const rightPadding = 20;

            const chartAreaWidth = canvasWidth - leftPadding - rightPadding;
            const chartAreaHeight = canvasHeight - topPadding - bottomPadding;
            const barSpacing = 15; // Spacing between bars

            // Calculate the maximum value for scaling the bars
            const maxValue = values.length > 0 ? Math.max(...values) : 0; // Handle empty values array
            // Add a buffer to the maxValue to make the y-axis taller than the highest bar
            const displayMaxValue = (maxValue > 0) ? maxValue * 1.1 : 100; // Default to 100 if no values

            // If all values are non-positive or no values, clear canvas and return
            if (values.length === 0 || displayMaxValue <= 0) { // Check displayMaxValue
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            // Calculate bar width based on number of bars and spacing
            const numBars = values.length;
            const availableBarWidthSpace = chartAreaWidth - (numBars > 0 ? (numBars - 1) * barSpacing : 0);
            const baseBarWidth = numBars > 0 ? availableBarWidthSpace / numBars : 0;


            // Draw Plot Area Background (ggplot2 style) for the entire canvas area
            ctx.fillStyle = '#e6e6e6'; // Gray background
            ctx.fillRect(0, 0, canvasWidth, canvasHeight); // Fill entire canvas

            // Draw horizontal grid lines (ggplot2 style)
            ctx.strokeStyle = '#ffffff'; // White for grid lines
            ctx.lineWidth = 1;
            const numYGridLines = 10; // Increased number of horizontal grid lines
            for (let i = 0; i <= numYGridLines; i++) {
                const y = topPadding + (chartAreaHeight / numYGridLines) * i;
                ctx.beginPath();
                ctx.moveTo(leftPadding, y);
                ctx.lineTo(leftPadding + chartAreaWidth, y);
                ctx.stroke();
            }

            // Draw vertical grid lines (ggplot2 style)
            const numXGridLines = numBars > 0 ? numBars : 10; // Base on numBars, or 10 if no bars
            for (let i = 0; i <= numXGridLines; i++) {
                 // Ensure grid lines are within the chart area boundaries
                const xGrid = leftPadding + (chartAreaWidth / numXGridLines) * i;
                ctx.beginPath();
                ctx.moveTo(xGrid, topPadding);
                ctx.lineTo(xGrid, canvasHeight - bottomPadding);
                ctx.stroke();
            }


            // Draw Plot Title
            ctx.fillStyle = '#1F2937'; // Dark gray
            ctx.font = 'bold 18px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(plotTitle, canvasWidth / 2, 15);

            // Draw Y-axis (values)
            ctx.beginPath();
            ctx.moveTo(leftPadding, topPadding);
            ctx.lineTo(leftPadding, canvasHeight - bottomPadding);
            ctx.strokeStyle = '#374151'; // Dark gray for axis
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw X-axis (categories)
            ctx.beginPath();
            ctx.moveTo(leftPadding, canvasHeight - bottomPadding);
            ctx.lineTo(canvasWidth - rightPadding, canvasHeight - bottomPadding);
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Y-axis labels and tick marks
            for (let i = 0; i <= numYGridLines; i++) { // Use numYGridLines for labels
                const value = (displayMaxValue / numYGridLines) * i; // Use displayMaxValue for label scaling
                const y = canvasHeight - bottomPadding - (value / displayMaxValue) * chartAreaHeight; // Use displayMaxValue for y-position

                ctx.fillStyle = '#4B5563'; // Gray for text
                ctx.font = '12px Inter';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(value), leftPadding - 5, y); // Label

                // Tick mark
                ctx.beginPath();
                ctx.moveTo(leftPadding, y);
                ctx.lineTo(leftPadding + 5, y);
                ctx.strokeStyle = '#9CA3AF'; // Light gray for tick marks
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw Y-axis Label
            ctx.save(); // Save the current canvas state
            ctx.translate(leftPadding - 40, canvasHeight / 2); // Move origin to desired text position
            ctx.rotate(-Math.PI / 2); // Rotate 90 degrees counter-clockwise
            ctx.fillStyle = '#1F2937'; // Dark gray
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(yAxisLabel, 0, 0);
            ctx.restore(); // Restore the canvas state

            // Draw X-axis Label
            ctx.fillStyle = '#1F2937'; // Dark gray
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(xAxisLabel, leftPadding + chartAreaWidth / 2, canvasHeight - bottomPadding + 25);


            // Draw bars
            let currentX = leftPadding; // Starting X position for the first bar
            for (let i = 0; i < numBars; i++) {
                const value = values[i];
                const category = categories[i] || `Category ${i + 1}`;
                const color = colors[i] || defaultColors[i % defaultColors.length]; // Use default colors if not provided

                // Use the pre-processed width from the 'widths' array
                const barPercentageWidth = widths[i] / 100;

                // Calculate bar height based on value (using displayMaxValue for consistent scaling)
                const barHeight = (value / displayMaxValue) * chartAreaHeight;

                // Calculate actual bar width
                const barActualWidth = baseBarWidth * barPercentageWidth;

                // Center the bar within its allocated space
                const x = currentX + (baseBarWidth - barActualWidth) / 2;
                const y = canvasHeight - bottomPadding - barHeight;

                // Draw the bar
                ctx.fillStyle = color;
                ctx.fillRect(x, y, barActualWidth, barHeight);
                ctx.strokeStyle = color; // Border same color
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barActualWidth, barHeight); // Add a subtle border

                // Draw category label below the bar
                ctx.fillStyle = '#4B5563'; // Gray for text
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(category, x + barActualWidth / 2, canvasHeight - bottomPadding + 5);

                // Draw value label above the bar
                ctx.fillStyle = '#1F2937'; // Darker gray for value text
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(value, x + barActualWidth / 2, y - 5);

                // Move to the next bar's starting position
                currentX += baseBarWidth + barSpacing;
            }
        }

        /**
         * Parses a comma-separated string into an array of numbers.
         * @param {string} inputString - The input string.
         * @returns {number[]} Array of numbers.
         */
        function parseNumbers(inputString) {
            return inputString.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
        }

        /**
         * Parses a comma-separated string into an array of strings.
         * @param {string} inputString - The input string.
         * @returns {string[]} Array of strings.
         */
        function parseStrings(inputString) {
            return inputString.split(',').map(s => s.trim()).filter(s => s.length > 0);
        }

        /**
         * Sorts the bar data (values, categories, colors, widths) in ascending order based on values.
         * Maintains correspondence between elements.
         * @param {number[]} values - Original array of values.
         * @param {string[]} categories - Original array of categories.
         * @param {string[]} colors - Original array of colors.
         * @param {number[]} widths - Original array of widths.
         * @returns {object} An object containing the sorted arrays.
         */
        function sortDataAscending(values, categories, colors, widths) {
            // Create an array of objects to keep data linked during sorting
            const data = values.map((value, index) => ({
                value: value,
                category: categories[index],
                color: colors[index],
                width: widths[index]
            }));

            // Sort the data array based on the 'value' property in ascending order
            data.sort((a, b) => a.value - b.value);

            // Extract the sorted arrays
            const sortedValues = data.map(item => item.value);
            const sortedCategories = data.map(item => item.category);
            const sortedColors = data.map(item => item.color);
            const sortedWidths = data.map(item => item.width);

            return {
                values: sortedValues,
                categories: sortedCategories,
                colors: sortedColors,
                widths: sortedWidths
            };
        }

        /**
         * Updates the display for value count and category hints.
         * @param {number[]} values - The parsed array of values.
         * @param {string[]} categories - The parsed array of categories.
         */
        function updateInputHints(values, categories) {
            valuesCountDisplay.textContent = `Values: ${values.length}`;

            const valuesCount = values.length;
            const categoriesCount = categories.length;

            if (valuesCount === categoriesCount) {
                if (valuesCount > 0) {
                    categoriesHintDisplay.textContent = 'Categories match values.';
                    categoriesHintDisplay.style.color = '#10B981'; // Green
                } else {
                    categoriesHintDisplay.textContent = ''; // No message if both are empty
                }
            } else if (categoriesCount < valuesCount) {
                const needed = valuesCount - categoriesCount;
                categoriesHintDisplay.textContent = `Need ${needed} more categorie(s).`;
                categoriesHintDisplay.style.color = '#EF4444'; // Red
            } else { // categoriesCount > valuesCount
                const extra = categoriesCount - valuesCount;
                categoriesHintDisplay.textContent = `${extra} extra categorie(s).`;
                categoriesHintDisplay.style.color = '#F59E0B'; // Amber
            }
        }

        /**
         * Adds a new row to the data table.
         * @param {number|string} value - Initial value for the new row.
         * @param {string} category - Initial category for the new row.
         * @param {string} color - Initial color for the new row.
         * @param {number|string} width - Initial width for the new row.
         */
        function addTableRow(value = '', category = '', color = '', width = '') {
            const row = dataTableBody.insertRow();
            row.className = 'hover:bg-gray-50'; // Add hover effect

            const valueCell = row.insertCell();
            valueCell.innerHTML = `<input type="text" value="${value}" class="table-value" placeholder="Value">`;

            const categoryCell = row.insertCell();
            categoryCell.innerHTML = `<input type="text" value="${category}" class="table-category" placeholder="Category">`;

            const colorCell = row.insertCell();
            colorCell.innerHTML = `<input type="text" value="${color}" class="table-color" placeholder="Color (optional)">`;

            const widthCell = row.insertCell();
            widthCell.innerHTML = `<input type="text" value="${width}" class="table-width" placeholder="Width (optional)">`;

            const deleteCell = row.insertCell();
            deleteCell.innerHTML = `<button type="button" class="delete-row-btn">X</button>`;
            deleteCell.className = 'text-center'; // Center the delete button

            // Add event listener for the delete button
            deleteCell.querySelector('.delete-row-btn').addEventListener('click', (event) => {
                event.target.closest('tr').remove();
                generatePlot('tableInput'); // Regenerate plot after deletion
            });

            // Add input listeners for live updates
            valueCell.querySelector('.table-value').addEventListener('input', () => generatePlot('tableInput'));
            categoryCell.querySelector('.table-category').addEventListener('input', () => generatePlot('tableInput'));
            colorCell.querySelector('.table-color').addEventListener('input', () => generatePlot('tableInput'));
            widthCell.querySelector('.table-width').addEventListener('input', () => generatePlot('tableInput'));
        }

        /**
         * Parses data from the HTML table.
         * @returns {object} An object containing values, categories, colors, and widths arrays.
         */
        function parseTableData() {
            const values = [];
            const categories = [];
            const colors = [];
            const widths = [];

            const rows = dataTableBody.querySelectorAll('tr');
            rows.forEach(row => {
                const value = parseFloat(row.querySelector('.table-value').value);
                const category = row.querySelector('.table-category').value.trim();
                const color = row.querySelector('.table-color').value.trim();
                const width = parseFloat(row.querySelector('.table-width').value);

                if (!isNaN(value)) {
                    values.push(value);
                } else {
                    values.push(0); // Push a default or handle error
                }

                categories.push(category);
                colors.push(color);
                widths.push(isNaN(width) ? undefined : width); // Use undefined if width is not a valid number
            });
            return { values, categories, colors, widths };
        }

        /**
         * Handles pasting of data into the table.
         * @param {ClipboardEvent} event - The paste event.
         */
        function handleTablePaste(event) {
            // Prevent default paste behavior to handle it manually
            event.preventDefault();

            // Get the pasted text data
            const pasteData = (event.clipboardData || window.clipboardData).getData('text');

            // Split the data into rows by newline, and then columns by tab
            const rows = pasteData.split('\n').map(row => row.split('\t'));

            let currentRowIndex = 0;
            // Iterate over pasted rows and populate table
            rows.forEach(pastedRow => {
                // Ensure we have a row to paste into
                let targetRow = dataTableBody.children[currentRowIndex];
                if (!targetRow) {
                    addTableRow(); // Add a new row if we run out of existing ones
                    targetRow = dataTableBody.children[currentRowIndex];
                }

                const inputs = targetRow.querySelectorAll('input[type="text"]');
                pastedRow.forEach((cellValue, cellIndex) => {
                    if (inputs[cellIndex]) {
                        inputs[cellIndex].value = cellValue.trim();
                    }
                });
                currentRowIndex++;
            });

            // After pasting, trigger a plot update
            generatePlot('tableInput');
        }

        /**
         * Toggles the visibility of input sections based on radio button selection.
         */
        function toggleInputMethod() {
            const selectedMethod = document.querySelector('input[name="inputMethod"]:checked').value;
            if (selectedMethod === 'commaSeparated') {
                commaSeparatedInput.classList.remove('hidden');
                tableInput.classList.add('hidden');
                // When switching back to comma separated, try to populate based on table data if available
                const tableData = parseTableData();
                if (tableData.values.length > 0) {
                    valuesInput.value = tableData.values.join(',');
                    categoriesInput.value = tableData.categories.join(',');
                    colorsInput.value = tableData.colors.filter(c => c).join(','); // Filter out empty colors
                    widthsInput.value = tableData.widths.filter(w => w !== undefined).join(','); // Filter out undefined widths
                }
            } else {
                commaSeparatedInput.classList.add('hidden');
                tableInput.classList.remove('hidden');
                // When switching to table, populate table based on comma-separated input if available
                const currentValues = parseNumbers(valuesInput.value);
                const currentCategories = parseStrings(categoriesInput.value);
                const currentColors = parseStrings(colorsInput.value);
                const currentWidths = parseNumbers(widthsInput.value);

                // Clear existing table rows
                dataTableBody.innerHTML = '';

                // Populate table with existing data
                const maxLen = Math.max(currentValues.length, currentCategories.length, currentColors.length, currentWidths.length);
                for (let i = 0; i < maxLen; i++) {
                    addTableRow(
                        currentValues[i] !== undefined ? currentValues[i] : '',
                        currentCategories[i] !== undefined ? currentCategories[i] : '',
                        currentColors[i] !== undefined ? currentColors[i] : '',
                        currentWidths[i] !== undefined ? currentWidths[i] : ''
                    );
                }
                // If no initial data, add a few empty rows for convenience
                if (maxLen === 0) {
                    addTableRow();
                    addTableRow();
                    addTableRow();
                }
            }
            // Trigger plot generation to reflect the change
            generatePlot(selectedMethod);
        }


        /**
         * Generates and draws the plot based on user input.
         * @param {string} [source='input'] - Indicates what triggered the plot generation (e.g., 'input', 'generateButton', 'sortButton', 'tableInput').
         */
        function generatePlot(source = 'input') {
            let values, categories, colors, widths;
            const selectedMethod = document.querySelector('input[name="inputMethod"]:checked').value;

            if (selectedMethod === 'commaSeparated') {
                values = parseNumbers(valuesInput.value);
                categories = parseStrings(categoriesInput.value);
                colors = parseStrings(colorsInput.value);
                widths = parseNumbers(widthsInput.value); // These should be percentages (0-100)
            } else { // tableInput
                const tableData = parseTableData();
                values = tableData.values;
                categories = tableData.categories;
                colors = tableData.colors;
                widths = tableData.widths;
            }

            const plotTitle = plotTitleInput.value;
            const xAxisLabel = xAxisLabelInput.value;
            const yAxisLabel = yAxisLabelInput.value;

            // Update hints only for comma-separated input, as table input provides immediate visual feedback
            if (selectedMethod === 'commaSeparated') {
                updateInputHints(values, categories);
            } else {
                // Clear hints if table input is active
                valuesCountDisplay.textContent = '';
                categoriesHintDisplay.textContent = '';
            }

            // --- Validation ---
            const hasEnoughData = values.length > 0 && categories.length > 0 && values.length === categories.length;
            const hasValidWidths = !widths.some(w => w < 0 || w > 100);

            if (!hasEnoughData || !hasValidWidths) {
                // Clear plot if invalid data, but only show message box for explicit clicks
                // Only show messages if the source is 'generateButton' and not automated updates
                // Since the generate button is removed, this block effectively only clears the chart if data is invalid
                if (source === 'generateButton') { // This condition will no longer be met for user clicks
                    if (values.length === 0) showMessageBox("Please enter at least one value.");
                    else if (categories.length === 0) showMessageBox("Please enter at least one category.");
                    else if (values.length !== categories.length) showMessageBox("Number of values must match the number of categories.");
                    else if (!hasValidWidths) showMessageBox("Bar widths must be between 0 and 100.");
                }
                ctx.clearRect(0, 0, barChartCanvas.width, barChartCanvas.height);
                // Ensure sort button state is reset if data becomes invalid
                currentChartIsSorted = false;
                sortAscendingBtn.textContent = 'Sort Ascending';
                return; // Stop execution if data is invalid
            }

            // --- Sorting Logic ---
            // If any input changes, or generate button is clicked, we reset the sorted state
            if (source === 'input' || source === 'tableInput') { // Removed 'generateButton' from source checks
                currentChartIsSorted = false;
                sortAscendingBtn.textContent = 'Sort Ascending'; // Reset button text
            } else if (source === 'sortButton') {
                // Toggle the sorted state when the sort button is pressed
                currentChartIsSorted = !currentChartIsSorted;
                sortAscendingBtn.textContent = currentChartIsSorted ? 'Unsort' : 'Sort Ascending';
            }

            // Apply sorting if the chart should currently be sorted
            if (currentChartIsSorted) {
                const sortedData = sortDataAscending(values, categories, colors, widths);
                values = sortedData.values;
                categories = sortedData.categories;
                colors = sortedData.colors;
                widths = sortedData.widths;
            }

            // Normalize widths array:
            // If only one width is provided, apply it to all bars.
            // If no widths are provided, apply the default of 50 to all bars.
            // Otherwise, use the provided widths, filling with 50 if individual width is missing.

            const numBars = categories.length; // Number of bars will be based on categories
            let finalWidths = [];

            if (widths.length === 1) {
                finalWidths = Array(numBars).fill(widths[0]);
            } else if (widths.length === 0) {
                finalWidths = Array(numBars).fill(50); // Default width 50
            } else {
                // If multiple widths are provided, use them. Fill missing ones with 50.
                for (let i = 0; i < numBars; i++) {
                    finalWidths.push(widths[i] !== undefined ? widths[i] : 50);
                }
            }
            widths = finalWidths; // Update the 'widths' variable for drawBarChart


            // Ensure canvas size is set to its CSS size
            // Use computed style to get accurate rendered dimensions
            const computedStyle = getComputedStyle(barChartCanvas);
            barChartCanvas.width = parseFloat(computedStyle.width);
            barChartCanvas.height = barChartCanvas.width; // Make it square based on width

            drawBarChart(barChartCanvas, ctx, values, categories, plotTitle, xAxisLabel, yAxisLabel, colors, widths);
        }

        // Removed event listener for the generate button as it's no longer needed
        // generatePlotBtn.addEventListener('click', () => generatePlot('generateButton'));

        // Event listener for the sort ascending/unsort button
        sortAscendingBtn.addEventListener('click', () => generatePlot('sortButton'));

        // Add input event listeners to all relevant input fields for live updates
        valuesInput.addEventListener('input', () => generatePlot('input'));
        categoriesInput.addEventListener('input', () => generatePlot('input'));
        plotTitleInput.addEventListener('input', () => generatePlot('input'));
        xAxisLabelInput.addEventListener('input', () => generatePlot('input'));
        yAxisLabelInput.addEventListener('input', () => generatePlot('input'));
        colorsInput.addEventListener('input', () => generatePlot('input'));
        widthsInput.addEventListener('input', () => generatePlot('input'));

        // Add event listeners for input method radio buttons
        inputMethodRadios.forEach(radio => {
            radio.addEventListener('change', toggleInputMethod);
        });

        // Add event listener for "Add Row" button
        addRowBtn.addEventListener('click', () => {
            addTableRow();
            // Automatically scroll to the new row if it's off-screen
            dataTableBody.lastChild.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            generatePlot('tableInput'); // Trigger plot update after adding row
        });

        // Add paste event listener to the table body for Excel paste functionality
        dataTableBody.addEventListener('paste', handleTablePaste);


        // Function to resize canvas and redraw chart on window resize
        function resizeCanvasAndRedraw() {
            // Get the computed dimensions after layout
            const computedStyle = getComputedStyle(barChartCanvas);
            const displayWidth = parseFloat(computedStyle.width);
            // Set the canvas drawing buffer resolution to be square
            barChartCanvas.width = displayWidth;
            barChartCanvas.height = displayWidth;

            // Call generatePlot with 'resize' source to redraw, keeping current sort state
            // This ensures the chart redraws correctly on resize while preserving the sort state
            generatePlot('resize');
        }

        // Initial plot generation and input method setup when the page loads
        window.onload = function() {
            // Set initial table data based on comma-separated values
            toggleInputMethod(); // This will also call generatePlot for the initial render
            resizeCanvasAndRedraw(); // Ensure canvas is sized correctly and initial plot is drawn
        };

        // Add event listener for window resize
        window.addEventListener('resize', resizeCanvasAndRedraw);

    </script>
</body>
</html>
